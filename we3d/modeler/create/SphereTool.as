package we3d.modeler.create{	import we3d.we3d;	import we3d.core.transform.Transform3d;	import we3d.material.Surface;	import we3d.mesh.Face;	import we3d.mesh.UVCoord;	import we3d.mesh.Vertex;	import we3d.scene.SceneObject;

	use namespace we3d;		/**	 * Creates a sphere	 */ 	public class SphereTool	{		/**		* Creates a sphere in a SceneObject		* 		* @paramsoObject for the points and polygons		* @paramsurfacesurface for the new polygons		* @paramsegXhorizontal division		* @paramsegYvertical division		* @paramradiusRadius of the sphere		* @parammakeQuadsBoolean if true the plane is made of Quads otherwise Triangles		* @paramtransformoptional apply a transform to the points of the new plane		*/		public static function create(so:SceneObject, surface:Surface, 		segX:int=8, segY:int=6,		radius:Number=50, makeQuads:Boolean=false,		transform:Transform3d=null, 		uStart:Number=0, vStart:Number=0,		uEnd:Number=1, vEnd:Number=1):void		{			var i:Number,j:Number,k:Number;			var iHor:Number = Math.max(3,segX);			var iVer:Number = Math.max(2,segY);			var aVertice:Vector.<Vertex >  = so.points;			var aFace:Vector.<Face >  = so.polygons;			var aVtc:Array = new Array();			for (j=0; j<(iVer+1); j++)			{// vertical				var fRad1:Number = Number(j / iVer);				var fZ:Number =  -  radius * Math.cos(fRad1 * Math.PI);				var fRds:Number = radius * Math.sin(fRad1 * Math.PI);				var aRow:Array = new Array();				var oVtx:Vertex;				for (i=0; i<iHor; i++)				{// horizontal					var fRad2:Number = Number(2 * i / iHor);					var fX:Number = fRds * Math.sin(fRad2 * Math.PI);					var fY:Number = fRds * Math.cos(fRad2 * Math.PI);					if (!((j==0||j==iVer)&&i>0))					{// top||bottom = 1 vertex						oVtx = new Vertex(fY,fZ,fX);						aVertice.push(oVtx);						so.objectCuller.testPoint( fY,fZ,fX );					}					aRow.push(oVtx);				}				aVtc.push(aRow);			}			var fc:Face;			var iVerNum:int = aVtc.length;			for (j=0; j<iVerNum; j++)			{				var iHorNum:int = aVtc[j].length;				if (j > 0)				{// &&i>=0					for (i=0; i<iHorNum; i++)					{						// select vertices						var bEnd:Boolean = i==(iHorNum-0);						var aP1:Vertex = aVtc[j][bEnd ? 0:i];						var aP2:Vertex = aVtc[j][(i==0?iHorNum:i)-1];						var aP3:Vertex = aVtc[j-1][(i==0?iHorNum:i)-1];						var aP4:Vertex = aVtc[j - 1][bEnd ? 0:i];						var fJ0:Number = j/ (iVerNum-1);						var fJ1:Number = (j-1)/ (iVerNum-1);						var fI0:Number = (i+1)/ iHorNum;						var fI1:Number = i/ iHorNum;						var aP4uv:UVCoord = new UVCoord(fI0,fJ1);						var aP1uv:UVCoord = new UVCoord(fI0,fJ0);						var aP2uv:UVCoord = new UVCoord(fI1,fJ0);						var aP3uv:UVCoord = new UVCoord(fI1,fJ1);						// 2 faces						if (j<(aVtc.length-1))						{							fc = new Face();							fc.surface = surface;							fc.vtxs = new Vector.<Vertex>();							fc.vtxs.push(aP1);							fc.vtxs.push(aP2);							fc.vtxs.push(aP3);							fc.uvs = new Vector.<UVCoord>();							fc.uvs.push(aP1uv);							fc.uvs.push(aP2uv);							fc.uvs.push(aP3uv);							fc.init(so);							aFace.push( fc );						}						if (j > 1)						{							fc = new Face();							fc.surface = surface;							fc.vtxs = new Vector.<Vertex>();							fc.vtxs.push(aP1);							fc.vtxs.push(aP3);							fc.vtxs.push(aP4);							fc.uvs = new Vector.<UVCoord>();							fc.uvs.push(aP1uv);							fc.uvs.push(aP3uv);							fc.uvs.push(aP4uv);							fc.init(so);							aFace.push( fc );						}					}				}			}		}	}}