package we3d.modeler.create{	import we3d.we3d;	import we3d.core.transform.Transform3d;	import we3d.material.Surface;	import we3d.mesh.Face;	import we3d.mesh.UVCoord;	import we3d.mesh.Vertex;	import we3d.scene.SceneObject;

	use namespace we3d;		/**	 * Creates a sphere	 */ 	public class DiscTool	{		/**		* Creates a disc in a SceneObject		* 		* @param so Object for the points and polygons		* @param surface Surface for the new polygons		* @param radius Radius of the cylinder		* @param height Height of the cylinder		* @param makeQuads Boolean if true the plane is made of Quads otherwise Triangles		* @param transform Optional, apply a transform to the points		*/		public static function create(	so:SceneObject, surface:Surface, 										sides:int=12, height:Number=100,										radius:Number=25, makePolygons:Boolean=false,										transform:Transform3d=null, 										uStart:Number=0, vStart:Number=0,										uEnd:Number=1, vEnd:Number=1):void		{			var h2:Number = height/2;			var px:Number = 0;			var pz:Number = 0;			var r:Number = 0;						var anglePerSide:Number = Math.PI*2 / sides;			var ids:Vector.<int> = new Vector.<int>();			var uvs:Vector.<UVCoord> = new Vector.<UVCoord>();						var ids2:Vector.<int> = new Vector.<int>();			var uvs2:Vector.<UVCoord> = new Vector.<UVCoord>();			var i:int;			var uc:Number = 1/sides;			var u:Number=0;						for(i=0; i<sides; i++) {				px = Math.sin(r)*radius;				pz = Math.cos(r)*radius;				r += anglePerSide;								ids.push( so.addPoint(px, h2, pz) );				uvs.push( new UVCoord(u,0) );				ids2.push( so.addPoint(px, -h2, pz) );				uvs2.push( new UVCoord(u,1) );				u += uc;			}						ids.reverse();			uvs.reverse();						var qi:Vector.<int>=new Vector.<int>();			var qu:Vector.<UVCoord>=new Vector.<UVCoord>();			var L:int = ids.length-1;						if(makePolygons) 			{				// add top poly:				so.addPolygonVector( surface, ids, uvs );				// add bottom poly:				so.addPolygonVector( surface, ids2, uvs2 );								for(i=0; i<L; i++) 				{					qi[0] = ids[L-i];					qi[1] = ids[L-(i+1)];					qi[2] = ids2[i+1];					qi[3] = ids2[i];										qu[0] = uvs[L-i];					qu[1] = uvs[L-(i+1)];					qu[2] = uvs2[i+1];					qu[3] = uvs2[i];										so.addPolygonVector( surface, qi, qu );				}								qi[0] = ids[0];				qi[1] = ids[L];				qi[2] = ids2[0];				qi[3] = ids2[L];								qu[0] = uvs[L];				qu[1] = uvs[L-1];				qu[2] = uvs2[L];				qu[3] = uvs2[L-1];								so.addPolygonVector( surface, qi, qu );							}			else			{				var pt:int = so.addPoint(0, h2, 0);				var pb:int = so.addPoint(0,-h2, 0);								var ut:UVCoord = new UVCoord();				var ub:UVCoord = new UVCoord();								for(i=0; i<L; i++) {					so.addTriangle( surface, pt, ids[i], ids[i+1], ut, uvs[i], uvs[i+1] );					so.addTriangle( surface, pb, ids2[i], ids2[i+1], ub, uvs2[i], uvs2[i+1] );				}				so.addTriangle( surface, pt, ids[L], ids[0], ut, uvs[L], uvs[0] );				so.addTriangle( surface, pb, ids2[L], ids2[0], ub, uvs2[L], uvs2[0] );								for(i=0; i<L; i++) 				{					qi[0] = ids[L-i];					qi[1] = ids[L-(i+1)];					qi[2] = ids2[i+1];					qi[3] = ids2[i];										qu[0] = uvs[L-i];					qu[1] = uvs[L-(i+1)];					qu[2] = uvs2[i+1];					qu[3] = uvs2[i];										so.addTriangle ( surface, qi[0],qi[1],qi[2], qu[0],qu[1],qu[2] );					so.addTriangle ( surface, qi[2],qi[3],qi[0], qu[2],qu[3],qu[0] );				}								qi[0] = ids[0];				qi[1] = ids[L];				qi[2] = ids2[0];				qi[3] = ids2[L];								qu[0] = uvs[L];				qu[1] = uvs[L-1];				qu[2] = uvs2[L];				qu[3] = uvs2[L-1];								so.addTriangle ( surface, qi[0],qi[1],qi[2], qu[0],qu[1],qu[2] );				so.addTriangle ( surface, qi[2],qi[3],qi[0], qu[2],qu[3],qu[0] );							}					}	}}