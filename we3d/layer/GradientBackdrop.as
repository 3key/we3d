package we3d.layer {	import com.adobe.utils.AGALMiniAssembler;		import flash.display.BitmapData;	import flash.display.GradientType;	import flash.display.InterpolationMethod;	import flash.display.SpreadMethod;	import flash.display.Sprite;	import flash.geom.Matrix;		import we3d.we3d;	import we3d.core.Camera3d;	import we3d.core.Object3d;	import we3d.core.transform.Transform3d;	import we3d.math.Matrix3d;	import we3d.math.Vector3d;	import we3d.renderer.RenderSession;

	use namespace we3d;		/**	* The GradientBackdrop fills the background image of a Layer with 4 colors. 	* The Gradient also rotates when the camera rotate to create the look of a ground and sky.	*/	public class GradientBackdrop extends SolidBackdrop  	{		public function GradientBackdrop (c1:uint=0x002850, c2:uint=0x78B4F0, c3:uint=0x32281E, c4:uint=0x64503C, _skySqeeze:Number=3, _groundSqueeze:Number=3) {			zenithColor = c1;			skyColor = c2;			groundColor = c3;			nadirColor = c4;			skySqeeze = _skySqeeze;			groundSqeeze = _groundSqueeze;		}				//private var model:Object;				private var _zenithColor:uint;		public var zenithAlpha:Number = 1;		private var _zenithR:Number;		private var _zenithG:Number;		private var _zenithB:Number;				/**		 * Upper sky color		 */		public function get zenithColor () :uint {	return _zenithColor;	}		public function set zenithColor (v:uint) :void {			_zenithColor = v;			_zenithR = (v >> 16 & 255)/255;			_zenithG = (v >> 8 & 255)/255;			_zenithB = (v & 255)/255;			buffersDirty = true;		}				/**		* Sky color in the middle		*/		private var _skyColor:uint;		private var _skyR:Number;		private var _skyG:Number;		private var _skyB:Number;		public var skyAlpha:Number = 1;		public function get skyColor () :uint {	return _skyColor;	}		public function set skyColor (v:uint) :void {			_skyColor = v;			_skyR = (v >> 16 & 255)/255;			_skyG = (v >> 8 & 255)/255;			_skyB = (v & 255)/255;			buffersDirty = true;		}				/**		* Sky sqeeze from 0-1		*/		public var skySqeeze:Number = 0;		/**		* Ground sqeeze from 0-1		*/		public var groundSqeeze:Number = 0;		/**		* Middle ground color		*/		private var _groundColor:uint;		public var groundAlpha:Number = 1;		private var _groundR:Number;		private var _groundG:Number;		private var _groundB:Number;		public function get groundColor () :uint {	return _groundColor;	}		public function set groundColor (v:uint) :void {			_groundColor = v;			_groundR = (v >> 16 & 255)/255;			_groundG = (v >> 8 & 255)/255;			_groundB = (v & 255)/255;			buffersDirty = true;		}		/**		* Bottom ground color		*/		private var _nadirColor:uint;		public var nadirAlpha:Number = 1;		private var _nadirR:Number;		private var _nadirG:Number;		private var _nadirB:Number;		public function get nadirColor () :uint {	return _nadirColor;	}		public function set nadirColor (v:uint) :void {			_nadirColor = v;			_nadirR = (v >> 16 & 255)/255;			_nadirG = (v >> 8 & 255)/255;			_nadirB = (v & 255)/255;			buffersDirty = true;		}				private var gpuUploaded:Boolean=false;		private var indexes:Vector.<uint>;		private var vertices:Vector.<Number>;		private var buffersDirty:Boolean=true;		private var program:Object;		private var agalVertex:AGALMiniAssembler;		private var agalFragment:AGALMiniAssembler;		private var vertexBuffer:Object;		private var indexBuffer:Object;		private var vec:Vector.<Number> = new Vector.<Number>(16);				public override function drawToGPU(session:RenderSession, lyr:Layer) :void 		{			if(session.context3d && session.context3d.driverInfo != "Disposed") 			{								if(buffersDirty || session.allBuffersDirty) 				{										/*if(!model)  {						model = new (Class(Object3d.getClass("flash.geom::Matrix3D")));					}*/										agalVertex = new AGALMiniAssembler();					agalFragment = new AGALMiniAssembler();										var agalVertexSource:String = "m44 op, va0, vc0 \nmov v0, va1 \n";					var agalFragmentSource:String = "mov oc, v0 \n";								agalVertex.assemble( "vertex", agalVertexSource );					agalFragment.assemble( "fragment", agalFragmentSource );										program = session.context3d.createProgram();					program.upload( agalVertex.agalcode, agalFragment.agalcode );										var yp:Number = -35 / groundSqeeze;					var yp2:Number = 35 / skySqeeze;										vertices = Vector.<Number>([ 												0, yp, 0, _nadirR, _nadirG, _nadirB, nadirAlpha, 												14.6946, yp, 0, _nadirR, _nadirG, _nadirB, nadirAlpha, 						10.3907, yp, 10.3907, _nadirR, _nadirG, _nadirB, nadirAlpha, 						0, yp, 14.6946, _nadirR, _nadirG, _nadirB, nadirAlpha, 						-10.3907, yp, 10.3907, _nadirR, _nadirG, _nadirB, nadirAlpha, 						-14.6946, yp, 0, _nadirR, _nadirG, _nadirB, nadirAlpha, 						-10.3907, yp, -10.3907, _nadirR, _nadirG, _nadirB, nadirAlpha, 						0, yp, -14.6946, _nadirR, _nadirG, _nadirB, nadirAlpha, 						10.3907, yp, -10.3907, _nadirR, _nadirG, _nadirB, nadirAlpha, 												23.7764, 0, 0, _groundR, _groundG, _groundB, groundAlpha,						16.8125, 0, 16.8125, _groundR, _groundG, _groundB, groundAlpha,						0, 0, 23.7764, _groundR, _groundG, _groundB, groundAlpha,						-16.8125, 0, 16.8125, _groundR, _groundG, _groundB, groundAlpha,						-23.7764, 0, 0, _groundR, _groundG, _groundB, groundAlpha,						-16.8125, 0, -16.8125, _groundR, _groundG, _groundB, groundAlpha,						0, 0, -23.7764, _groundR, _groundG, _groundB, groundAlpha,						16.8125, 0, -16.8125, _groundR, _groundG, _groundB, groundAlpha,												23.7764, 0, 0,  _skyR, _skyG, _skyB, skyAlpha,						16.8125, 0, 16.8125,  _skyR, _skyG, _skyB, skyAlpha,						0, 0, 23.7764,  _skyR, _skyG, _skyB, skyAlpha,						-16.8125, 0, 16.8125,  _skyR, _skyG, _skyB, skyAlpha,						-23.7764, 0, 0,  _skyR, _skyG, _skyB, skyAlpha,						-16.8125, 0, -16.8125,  _skyR, _skyG, _skyB, skyAlpha,						0, 0, -23.7764,  _skyR, _skyG, _skyB, skyAlpha,						16.8125, 0, -16.8125,  _skyR, _skyG, _skyB, skyAlpha,												14.6946, yp2, 0, _zenithR, _zenithG, _zenithB, zenithAlpha, 						10.3907, yp2, 10.3907, _zenithR, _zenithG, _zenithB, zenithAlpha, 						0, yp2, 14.6946, _zenithR, _zenithG, _zenithB, zenithAlpha, 						-10.3907, yp2, 10.3907, _zenithR, _zenithG, _zenithB, zenithAlpha, 						-14.6946, yp2, 0, _zenithR, _zenithG, _zenithB, zenithAlpha, 						-10.3907, yp2, -10.3907,_zenithR, _zenithG, _zenithB, zenithAlpha,  						0, yp2, -14.6946, _zenithR, _zenithG, _zenithB, zenithAlpha, 						10.3907, yp2 , -10.3907, _zenithR, _zenithG, _zenithB, zenithAlpha, 												0, yp2, 0, _zenithR, _zenithG, _zenithB, zenithAlpha					]);										if(!indexes) {						indexes = Vector.<uint>([														0, 8, 1, 							0, 1, 2, 							0, 2, 3, 							0, 3, 4, 							0, 4, 5, 							0, 5, 6, 							0, 6, 7, 							0, 7, 8, 							8, 16, 9, 							1, 8, 9, 							1, 9, 10, 							2, 1, 10, 							2, 10, 11, 							3, 2, 11, 							3, 11, 12, 							4, 3, 12, 							4, 12, 13, 							5, 4, 13, 							5, 13, 14, 							6, 5, 14, 							6, 14, 15, 							7, 6, 15, 							7, 15, 16, 							8, 7, 16,																	24, 32, 25, 							17, 24, 25, 							17, 25, 26, 							18, 17, 26, 							18, 26, 27, 							19, 18, 27, 							19, 27, 28, 							20, 19, 28, 							20, 28, 29, 							21, 20, 29, 							21, 29, 30, 							22, 21, 30, 							22, 30, 31, 							23, 22, 31, 							23, 31, 32, 							24, 23, 32, 							25, 32, 33, 							26, 25, 33, 							27, 26, 33, 							28, 27, 33, 							29, 28, 33, 							30, 29, 33, 							31, 30, 33, 							32, 31, 33						]);										}										vertexBuffer = session.context3d.createVertexBuffer(vertices.length/7, 7);					vertexBuffer.uploadFromVector(vertices, 0, vertices.length/7);										indexBuffer = session.context3d.createIndexBuffer(indexes.length);					indexBuffer.uploadFromVector(indexes, 0, indexes.length);										buffersDirty = false;				} // if buffersdirty								var gv:Matrix3d = session.camera.cgv;								var mt:Matrix3d = new Matrix3d();				var tr:Matrix3d = new Matrix3d();								tr.m = session.camera.transform.gv.m;				tr.n = session.camera.transform.gv.n;				tr.o = session.camera.transform.gv.o;												mt.concatM4( tr, session.camera.cgv, mt);				/*				vec[0] = mt.a;				vec[1] = mt.b;				vec[2] = mt.c;				vec[3] = mt.c;								vec[4] = mt.e;				vec[5] = mt.f;				vec[6] = mt.g;				vec[7] = mt.g;								vec[8] = mt.i;				vec[9] = mt.j;				vec[10] = mt.k;				vec[11] = mt.k;								vec[12] = mt.m;				vec[13] = mt.n;				vec[14] = mt.o;				vec[15] = mt.o + session.camera._nearClipping;				*/								vec[0] = mt.a; vec[1] = mt.e; vec[2] = mt.i; vec[3] = mt.m;				vec[4] = mt.b; vec[5] = mt.f; vec[6] = mt.j; vec[7] = mt.n;				vec[8] = mt.c; vec[9] = mt.g; vec[10] = mt.k; vec[11] = mt.o;				vec[12] = mt.c; vec[13] = mt.g; vec[14] = mt.k;				vec[15] = mt.o + session.camera._nearClipping;								//model.rawData = vec;								session.context3d.setDepthTest(false, "always");				session.context3d.setProgram( program );								session.context3d.setBlendFactors("sourceAlpha","oneMinusSourceAlpha");				session.gpuBlendMode = 1;								//session.context3d.setProgramConstantsFromMatrix("vertex", 0, model, true);				session.context3d.setProgramConstantsFromVector("vertex", 0, vec);								//session.context3d.setTextureAt( 0, null );				session.context3d.setVertexBufferAt( 0, vertexBuffer, 0, "float3" );				session.context3d.setVertexBufferAt( 1, vertexBuffer, 3, "float4" );				//session.context3d.setVertexBufferAt( 2, null);				session.gpuBuffers = 2;												session.context3d.drawTriangles(indexBuffer);				session.context3d.setDepthTest(true, "less");			}		}				public override function drawToBitmap (session:RenderSession, lyr:Layer) :void {						var bmp:BitmapData = lyr.bmp;			var wr:Vector3d = session.camera.transform.worldRotation;						var mrz:Transform3d = new Transform3d();			mrz.rotationZ = -wr.z;						var gv:Matrix3d = new Matrix3d();			gv.concatM4(mrz.gv, session.camera.transform.gv, gv);						var inv:Matrix3d = new Matrix3d();			inv.a = gv.a;	inv.b = gv.e;	inv.c = gv.i;			inv.e = gv.b;	inv.f = gv.f;	inv.g = gv.j;			inv.i = gv.c;	inv.j = gv.g;	inv.k = gv.k;						var x:Number = gv.m;	var y:Number = gv.n;	var z:Number = gv.o;						inv.m = -(x * gv.a + y * gv.b + z * gv.c); 			inv.n = -(x * gv.e + y * gv.f + z * gv.g);			inv.o = -(x * gv.i + y * gv.j + z * gv.k);						var mat:Matrix3d = session.camera.pr;			var cgvb:Number = inv.a*mat.b + inv.b*mat.f + inv.c*mat.j;			var cgvc:Number = inv.a*mat.c + inv.b*mat.g + inv.c*mat.k;			var cgvf:Number = inv.e*mat.b + inv.f*mat.f + inv.g*mat.j;			var cgvg:Number = inv.e*mat.c + inv.f*mat.g + inv.g*mat.k;			var cgvj:Number = inv.i*mat.b + inv.j*mat.f + inv.k*mat.j;			var cgvk:Number = inv.i*mat.c + inv.j*mat.g + inv.k*mat.k;			var cgvn:Number = inv.m*mat.b + inv.n*mat.f + inv.o*mat.j + mat.n;			var cgvo:Number = inv.m*mat.c + inv.n*mat.g + inv.o*mat.k + mat.o;						var tr:Transform3d = new Transform3d();			tr.transform = session.camera.transform.gv;			var pi2:Number = Math.PI/2;			var rz:Number = tr.rotationZ;			var zy:Number = tr.zAxis.y;			var rd:Number = zy*pi2;						var mtx:Matrix = new Matrix();						var fov:Number = session.camera.fov;			var fov2:Number = fov/2;						var wt:Number = rd + fov2;			var wb:Number = rd - fov2;			var cx:Number = bmp.width/2;			var cy:Number = bmp.height/2;						var mw:Number = (Math.sqrt(cx*cx + cy*cy)*2 - Math.max(bmp.width, bmp.height))*4;			var ofs:Number = mw/2;						var sp:Sprite = new Sprite();			var sqa:Number;			var sqstart:Number;						var fp:Vector3d = new Vector3d(0.0005, 0.0005, 0x7fffffff);						var w:Number = cgvc*fp.x + cgvg*fp.y + cgvk*fp.z + cgvo + session.camera._nearClipping;						var xr:int;	var xg:int;	var xb:int; var xa:Number;			var yr:int;	var yg:int;	var yb:int;			var zr:int;	var zg:int;	var zb:int;			var grs:Number=0;			var gre:Number=255;			var cnt:Number;			var d:Number;			var gp:Number;						cnt = session.camera.s - (cgvb*fp.x + cgvf*fp.y + cgvj*fp.z + cgvn)/w * session.camera.s;						if(cnt > -ofs) {				if(skySqeeze == 0) {					sp.graphics.beginFill(skyColor, skyAlpha);				}				else{					sqa = (Math.PI*4)/(skySqeeze+1);					sqstart = sqa;										xr = zenithColor >> 16 & 255;					xg = zenithColor >> 8 & 255;					xb = zenithColor & 255;										yr = skyColor >> 16 & 255;					yg = skyColor >> 8 & 255;					yb = skyColor & 255;										d = wt/sqstart;										if(d>1) {						xa = zenithAlpha;						zr = xr;						zg = xg;						zb = xb;						gp = cnt - (sqstart/wt*cnt) - 1;												mtx.createGradientBox(bmp.width, cnt-gp, pi2, 0, gp);												sp.graphics.beginGradientFill(											GradientType.LINEAR, 											[zr<<16 | zg<<8 | zb, 	skyColor],											[xa, 	skyAlpha],											[grs, 	gre], mtx											);					}					else{						d = 1-d;						if(d < 1) {														xa = zenithAlpha + (skyAlpha-zenithAlpha) * d;							zr = xr + (yr-xr)*d;							zg = xg + (yg-xg)*d;							zb = xb + (yb-xb)*d;							mtx.createGradientBox(bmp.width, cnt, pi2, 0, 0);														sp.graphics.beginGradientFill(											GradientType.LINEAR, 											[zr<<16 | zg<<8 | zb, 	skyColor],											[xa, 	skyAlpha],											[grs, 	gre], mtx											);						}						else{							// SKY ONLY							sp.graphics.beginFill(skyColor, skyAlpha);						}					}				}								// Draw Sky Rect				sp.graphics.drawRect(-ofs, -ofs, bmp.width + mw, cnt + ofs);				sp.graphics.endFill();			}						if(cnt < bmp.height+ofs) {				if(groundSqeeze == 0) 				{					sp.graphics.beginFill(groundColor, groundAlpha);				}				else				{					sqa = (Math.PI*4)/(groundSqeeze+1);					sqstart = -sqa;										// gradient ground											xr = groundColor >> 16 & 255;					xg = groundColor >> 8 & 255;					xb = groundColor & 255;										yr = nadirColor >> 16 & 255;					yg = nadirColor >> 8 & 255;					yb = nadirColor & 255;										d = wb/sqstart;										if(d > 1) {												xa = nadirAlpha;						zr = yr;						zg = yg;						zb = yb;												var bth:Number = bmp.width - cnt;						gp = bth - (sqstart/wb*bth);						mtx.createGradientBox(bmp.width, bth-gp, pi2, 0, cnt);												sp.graphics.beginGradientFill(											GradientType.LINEAR, 											[groundColor, zr<<16 | zg<<8 | zb],											[groundAlpha, xa],											[grs, 	gre], mtx											);					}					else					{						if(d > 0) {														xa = groundAlpha + (nadirAlpha-groundAlpha) * d;							zr = xr + (yr-xr)*d;							zg = xg + (yg-xg)*d;							zb = xb + (yb-xb)*d;														mtx.createGradientBox(bmp.width, (bmp.height+ofs)-cnt, pi2, 0, cnt);														sp.graphics.beginGradientFill(											GradientType.LINEAR, 											[groundColor, zr<<16 | zg<<8 | zb],											[groundAlpha, xa],											[grs, 	gre], mtx											);						}						else						{							// GROUND ONLY							sp.graphics.beginFill(groundColor, groundAlpha);						}					}				}				sp.graphics.drawRect(-ofs, cnt, bmp.width + mw, (bmp.height-cnt) + ofs);				sp.graphics.endFill();			}			var mt2:Matrix = new Matrix();						mt2.translate(-(bmp.width)/2, -(bmp.height)/2);			mt2.rotate(rz);			mt2.translate((bmp.width)/2, (bmp.height)/2);						bmp.draw(sp, mt2, null,null,bmp.rect,true);		}		}}